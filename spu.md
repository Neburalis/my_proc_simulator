# Учебный процессор: документация

## Общее описание

Этот проект представляет собой **учебный симулятор процессора**, разработанный для изучения основ архитектуры процессоров, машинного кода и выполнения программ на низком уровне. Процессор работает с **байткодом**, скомпилированным из упрощённого ассемблера, и использует стековую модель вычислений с ограниченной памятью и фиксированным набором инструкций.

---

## Архитектурные особенности

- **Тип данных в стеке и регистрах**: все значения представлены как `double` (64-битные числа с плавающей точкой).
- **Оперативная память**: 1024 байта, организована как массив байтов (`char`).
  - Используется как **универсальное хранилище**, в том числе как **текстовая видеопамять** (например, для команды `DRAW`).
  - При записи значения типа `double` в память (через `POPM`) оно преобразуется следующим образом:
    - Берётся **целая часть** числа (отбрасывается дробная).
    - Результат приводится к типу `char` по правилам языка C:
      `mem[addr] = (char)value;`
    - Это означает, что значение ограничивается диапазоном **0–255** (если `char` беззнаковый)
  - При чтении из памяти (через `PUSHM`) один байт по указанному адресу интерпретируется как **целое число от 0 до 255** и помещается в стек как `double`.
- **Стек данных**: неограниченного размера, хранит значения типа `double`.
- **Стек вызовов**: неограниченного размера, используется для хранения адресов возврата при вызове функций.
- **Регистры**: 8 регистров общего назначения, все хранят значения типа `double`.

### Регистры

Процессор содержит следующие регистры:

- `RAX`
- `RBX`
- `RCX`
- `RDX`
- `RTX`
- `DED`
- `INSIDE`
- `CURVA`

> Имена регистров выбраны произвольно и не несут семантической нагрузки. Все регистры равноправны и могут использоваться для любых целей.

- **Размер инструкции**: каждая команда байткода занимает **64 бита (8 байт)** — это упрощает загрузку и обработку, так как совпадает с размером `double`.

---

## Формат байткода

Каждый исполняемый файл байткода **обязательно начинается с заголовка**, содержащего следующие поля (в порядке следования):

| Поле | Описание |
|------|----------|
| `PROC_SIGNATURE` | Уникальная hex-подпись процессора (идентификатор архитектуры). |
| `BYTECODE_COMMANDS_VERSION` | Версия формата команд (для обеспечения совместимости). |
| `COUNT_OF_BYTES_IN_BYTECODE` | Общее количество **байт** в байткоде (включая заголовок и все инструкции). |
| `ASSEMBLY_DATE` | Дата компиляции байткода (в формате `YYYY-MM-DD`). |

> [! IMPORTANT]
> **Важно**: если `PROC_SIGNATURE` не совпадает с ожидаемой сигнатурой процессора, **байткод не будет запущен**. Это защита от запуска кода, предназначенного для других архитектур.

---

## Поддержка меток в ассемблере
Ассемблер (компилятор из .asm в байткод) поддерживает произвольные текстовые метки, которые упрощают написание циклов и ветвлений.

#### Синтаксис меток
Метка записывается в отдельной строке и начинается с двоеточия:

```
:<имя_метки>
```
- <имя_метки> — любая последовательность печатных символов (без управляющих символов), заканчивающаяся символом новой строки \n.
- Имя метки чувствительно к регистру.
- Метки не занимают места в байткоде — они существуют только на этапе компиляции.

### Использование меток
Метки можно использовать в качестве операндов для инструкций перехода (`JMP`, `JB`, `JBE`, `JA`, `JAE`, `JE`, `JNE`, `CALL`).
Компилятор автоматически:

1. Вычисляет адрес (PC), соответствующий позиции метки в байткоде.
1. Подставляет этот адрес вместо имени метки в соответствующую инструкцию.

###Пример

```asm
PUSH 0
POPR RAX
; RAX = 0

; метка "loop"
:loop

; тело цикла

; инкремент
PUSHR RAX
PUSH 1
ADD
POPR RAX
; RAX += 1

PUSHR RAX
PUSH 10
JB :loop
; если RAX < 10 → перейти к :loop

HLT
```

Этот код эквивалентен следующему циклу на C:

```c
for (double a = 0; a < 10; a += 1) {
    // тело цикла (в данном случае пустое)
}
```

> Метки делают код читаемым и избавляют программиста от ручного подсчёта адресов инструкций и ошибок при этом.

---

## Набор инструкций

### Управление выполнением
- `HLT` — завершить выполнение программы.
- `JMP <pc>` — безусловный переход на адрес `pc`.
- Условные переходы (сравнивают два верхних элемента стека: сначала извлекается `b`, затем `a`; проверяется условие `a OP b`):\
(оба элемента будут удалены из стека)
  - `JB` — jump if below (`a < b`)
  - `JBE` — jump if below or equal (`a <= b`)
  - `JA` — jump if above (`a > b`)
  - `JAE` — jump if above or equal (`a >= b`)
  - `JE` — jump if equal (`a == b`)
  - `JNE` — jump if not equal (`a != b`)
- `CALL <pc>` — вызов подпрограммы (сохраняет адрес возврата в стек вызовов и переходит на `pc`).
- `RET` — возврат из подпрограммы (восстанавливает адрес из стека вызовов).

### Работа со стеком, регистрами и памятью
- `PUSH <число>` — поместить константу (`double`) в стек.
- `POPR <reg>` — извлечь значение из стека и записать в регистр `<reg>`. Значение регистра будет перезаписано, а старое - утеряно.
- `PUSHR <reg>` — поместить значение из регистра `<reg>` в стек. Значение регистра сохранится.
- `POPM [<reg>]` — извлечь значение из стека, преобразовать его в байт по правилу `(char)floor(value)`, и записать **один байт** в память по адресу, указанному в регистре `<reg>`. Значение в памяти будет перезаписано, а старое - утеряно.
- `PUSHM [<reg>]` — прочитать **один байт** из памяти по адресу из регистра `<reg>`, интерпретировать его как число от 0 до 255 и поместить в стек как `double`. Значение в памяти сохранится (аналог регистров, не не именованные).

### Арифметические и математические операции
(оперируют верхними элементами стека; результат помещается обратно)

- `ADD`, `SUB`, `MUL`, `DIV` — базовые арифметические операции.
- `IDIV` — деление с последующим округлением результата **вниз до целого** (возвращается как `double`).
- `MOD` — остаток от деления (`a - b * floor(a / b)`).
- `SQRT` — квадратный корень (`√a`).
- `SIN`, `COS` — синус и косинус (аргумент в радианах).

> Все бинарные операции извлекают два значения (значения будут утеряны): сначала `b`, затем `a`, вычисляют `a OP b`, и кладут результат в стек.

### Ввод/вывод и графика
- `IN` — считать число (`double`) из терминала и поместить в стек.
- `OUT` — извлечь значение из стека и вывести в терминал. Значение будет утеряно.
- `DRAW <delay_ns>` — отобразить содержимое **видеопамяти** (вся оперативная память размером 1024 байта интерпретируется как текстовый буфер: 32 строки × 32 символа). Значения будут сохранены.
  Задержка `<delay_ns>` указывает, сколько наносекунд ждать перед следующим кадром (для анимации).

---

## Особенности видеопамяти

- Вся оперативная память (`1024 байта`) может использоваться как **текстовый видеобуфер**.
- Каждый байт соответствует одному **ASCII-символу**.
- При вызове `DRAW` симулятор выводит содержимое памяти как сетку `32×32` (например, в консоль или окно).
- Чтобы отобразить символ `'A'` (код 65) в позиции (0,0), нужно:
  1. Положить `65.0` в стек.
  2. Записать его в память по адресу `0` через `POPM`.

Пример:
```asm
PUSH 65.0
; ASCII-код символа 'A'
PUSH 0.0
; адрес 0
POPR RBX
; адрес в RBX
POPM [RBX]
; записать (char)65.0 → mem[0] = 65
DRAW 0
; отобразить буфер

HLT
```

---

## Цель проекта

Данный симулятор разработан в **учебных целях** для:
- Изучения взаимодействия между стеком, регистрами и памятью.
- Понимания принципов текстовой графики и видеобуферов.
- Практики написания программ на низкоуровневом ассемблере.
- Экспериментов с компиляцией и исполнением собственного байткода.

---

> Дата составления документации: 2025-10-20 \
> © Neburalis github.com/neburalis neburalis.space \
> Учебный проект. Не предназначен для промышленного использования.